\chapter{Umsetzung}

Die Sensoren werden an einen Raspberry Pi angeschlossen und melden die
gemessenen Werte an einen zentralen Raspberry Pi. Der zentrale Raspberry Pi legt
die gemeldeten Daten in einer Datenbank ab. Eine Webseite greift auf die
Datenbank zu und stellt die Daten dar.\\
Die Kommunikation wird über ein eigenes WLAN-Netz abgewickelt das von der
Zentraleinheit aufgespannt wird. IP-Adressen werden von einem \ac{DHCP}-Server, der
auf der Zentraleinheit installiert ist vergeben.\\
Die Website wird durch einen Apache-Webserver auf der Zentraleinheit
bereitgestellt.

%Harm
\section{Netzwerkkonfiguration}
%TODO: Einleitender satz
%TODO: WLAN-Stick
%TODO: Acro WLAN Anmerkung: WLAN ist eine allgemein bekannte Abkürzung und muss nicht erklärt werden!!
%Passt
\subsection{WLAN}
%TODO: Wird von der Zentraleinheit aufgespannt
Es wird ein Funknetz auf Basis des 802.11n Standards verwendet. Aufgespannt wird das WLAN von der Zentraleinheit, auf der zentrale Dienste bereitgestellt werden. Als Name wurde Pinet festgelegt, der von allen gesehen werden kann. In der Tabelle (siehe \fullref{tab:WLAN-Konfiguration}) sind die einzelnen Optionen aufgeführt und erläutert.

 
\begin{table}
\caption{WLAN-Konfigurationsdetails}
\label{tab:WLAN-Konfiguration}
\begin{tabular}{p{0.5\textwidth} p{0.45\textwidth}}
\textbf{Befehl} 						& \textbf{Erklärung} \\
interface=wlan0 						& Das Interface auf dem das Funknetz ausgestrahlt wird \\
ssid=Pinet 									& Der Name des Funknetzes \\
country\_code=DE 						& Über die Festlegung der Region wird sichergestellt, dass das Funknetz die spezifischen Grenzwerte für Kanäle oder Sendestärke einhält \\
hw\_mode=g 									& Legt fest, dass das Funknetz im 2,4 GHz-Band ausgestrahlt wird \\
channel=6 									& Der Funkkanal 6 wird verwendet \\
macaddr\_acl=0 							& MAC-Adressenfilterung ist deaktiviert \\
auth\_algs=1 								& Legt fest, dass als Verschlüsselung \ac{WPA} verwendet wird \\
ignore\_broadcast\_ssid=0 	& Die \ac{SSID} wird ausgestrahlt und nicht versteckt. \\
wpa=2 											& Legt die WPA-Version fest auf \ac{WPA2} \\
wpa\_passphrase=********** 	& Legt den \ac{PSK} fest \\
wpa\_key\_mgmt=WPA-PSK 			& Legt fest, dass ein \ac{PSK} verwendet wird \\
wpa\_pairwise=CCMP 					& Legt fest, dass nur der \ac{AES}-Verschlüsselungsalgorithmus verwendet wird \\
wpa\_group\_rekey=86400 		& Legt fest, dass alle 86400 Sekunden ein neuer Schlüssel verwendet werden muss \\
ieee80211n=1 								& Aktiviert den n-Standard \\
wme\_enabled=1 							& Aktiviert \ac{QoS} - Voraussetzung für die Verwendung des n-Standards \\
 \end{tabular}
\end{table}
%passt
\subsection{Verschlüsselung}

Wie aus der \fullref{tab:WLAN-Konfiguration} hervorgeht, ist das WLAN mit \ac{WPA2} verschlüsselt. \ac{WPA2} gilt aktuell als sicher, was nicht für die Alternativen \ac{WEP} oder \ac{WPA} gilt. Zur Authentifizierung wird ein \ac{PSK} verwendet. Als Verschlüsselungsprotokoll wird \ac{CCMP} verwendet. 

%passt
\subsection{\ac{DHCP}}
 
Als \ac{DHCP}-Server wird der ISC-DHCP-Server verwendet.\\
Die IP-Adressen werden nur über das wlan0-Interface der Zentraleinheit vergeben. Als Netz wird das private Netz 192.168.178.0 /24 verwendet. In diesem Netz hat die Zentraleinheit als \ac{DHCP}-Server die Adresse 192.168.178.1 /24. Diese Adresse ist statisch eingetragen. Alle anderen Geräte erhalten dynamische IP-Adressen aus dem Bereich 192.168.178.10 - 192.168.178.250. Die Lease-Time wurde auf 604800 Sekunden festgelegt. Dies entspricht 7 Tagen. Als Lease-Time wird der Zeitraum bezeichnet, in dem ein Netzwerkgerät, die gleiche IP-Adresse erhält. So wird verhindert, dass viele Adressänderungen stattfinden. Da nur wenige Geräte im Netz verfügbar sind und auch keine häufigen Änderungen erwartet werden, wird der Zeitraum von 7 Tagen als ausreichend angesehen. Damit der \ac{DHCP}-Server die IP-Adressen nur im WLAN vergibt, wird die IP-Adress-Vergabe auf das Interface wlan0 eingeschränkt.



\begin{lstlisting}[caption=Konfiguration des ISC-DHCP-Server,frame=single]
#Rogue-DHCP-Server nicht erlauben (Doppelter DHCP-Server)
authoritative;

#Definition des Subnetzes
subnet 192.168.178.0 netmask 255.255.255.0
{
        #Angabe der DHCP-Range
        range 192.168.178.10 192.168.178.250;

        #Angabe der Lease-Times 7 Tage in sekunden
        default-lease-time 604800;
        max-lease-time 604800;

        #Begrenzung auf das WLAN-Interface
        interface wlan0;
}

\end{lstlisting}

%Alex
%Passt
\section{Sensorknoten} %Allgemein Vorinstalation!
Für die Umsetzung des Sensorknotens werden vorab Pythonbibliotheken benötigt. Sie werden mit dem folgenden Befehl im Quellcode hinzugefügt:
\begin{lstlisting}[caption=Importbefehl in Python,frame=single,numbers=left,language=Python]
# Hinzufügen eines kompletten Paketes
import <Paketname> as <Aliasname>
# Hinzufügen einer Methode aus einem Paket
from <Paketname> import <Methodenname>
\end{lstlisting}
%TODO: Tabelle daraus machen
Folgende Pakete werden benötigt:
\begin{enumerate}
	\item RPi.GPIO
	\item smbus
	\item socket
	\item json
	\item Adafruit\_DHT
\end{enumerate}

RPi.GPIO ist die Bibliothek zur Nutzung der \ac{GPIO} Schnittstelle in Python. Das Paket smbus ermöglicht den Zugriff auf die I$^2$C Schnittstelle. Das Paket socket ermöglicht die Nutzung der TCP/IP Socketverbindung. Mittels json kann das Datenformat \ac{JSON} genutzt werden. Python bietet mit Hilfe der Adafruit\cite{Adafruit60:online} Bibliotheken eine Schnittstelle zu den Sensoren. Die Adafruitbibliothek kann mit Hilfe des pythoneigenen Paketmanagers, "'pip"', installiert werden.
\begin{lstlisting}[caption=Installation der Adafruit Bibliothek mit pip,frame=single]
pip install adafruit_python_dht
\end{lstlisting}
Dieses Paket wird zum Ansteuern des DHT-11 Sensors, der im \fullref{Sensoren_Planung} beschrieben wird, benötigt. Die genutzte Erweiterungsplatine RPI - Explorer 700 benötigt keine zusätzliche Software. Die Platine muss auf die \ac{GPIO} Pins gesteckt werden, um funktional zu sein. Der \ac{A/D-Wandler} befindet sich neben den \ac{GPIO} Anschlüssen und hat eine gelbe Platinenfarbe. Bevor der \ac{A/D-Wandler} einsatzfähig ist muss der I$^2$C Bus in der Raspi-config Datei aktiviert werden. Mit dem aktiven I$^2$C Bus können die Sensoren ausgelesen werden.
%Passt
\subsection{Verdrahtung der Sensoren}\label{Verdrahtung_der_Sensoren}
%Die Sensoren werden bestimmten Pins zugewiesen, damit sowohl erfahrene als auch unerfahrene Nutzer dieses Sensorknotensystem nachbauen können.
Die Sensoren, aus dem \fullref{Sensoren_Planung}, haben eine feste Zuweisung an die jeweiligen Pins. Dies ermöglicht es anderen Nutzern das System einfacher und schneller nachzubauen, ohne Probleme bei der Verbindung der Sensoren zu bekommen. Die Tabelle \fullref{tab:Pinbelegung} beschreibt die Belegung der einzelnen Pins.
\begin{table}[htp]
	\caption{GPIO und analoge Pinbelegung der Sensoren}
	\label{tab:Pinbelegung}
	\begin{tabular}{p{0.15\textwidth} p{0.2\textwidth} p{0.6\textwidth}}
		\textbf{GPIO-Pin}	& \textbf{Sensor} & \textbf{Beschreibung} \\
		Pin 5 		& Schocksensor 	& Funktionsweise über die Flankendetektion\\	
		Pin 17		& Flammensensor	& True oder False Wert vom Sensor\\
		Pin 18		& Mikrofon		& True oder False Wert vom Sensor\\
		Pin 24		& Lichtschranke	& True oder False Wert vom Sensor\\
		Pin 25		& DHT11 Sensor	& Luftfeuchtigkeits- und Temperaturwerte werden als digitale Werte geliefert
	\end{tabular}
\end{table}
\begin{table}[htp]
	\begin{tabular}{p{0.15\textwidth} p{0.2\textwidth} p{0.6\textwidth}}
		\textbf{Analog-Pin}	& \textbf{Sensor} & \textbf{Beschreibung} \\
		A0	& Mikrofon 		& Analoge Messwerte des Mikrofons. Werden zur Fehlererkennung genutzt. \\
		A1	& Flammensensor	& Analoge Messwerte des Flammensensors. Werden zur Fehlererkennung genutzt.\\
		A2	& Lichtsensor	& Analoge Messwerte des Lichtsensors.
	\end{tabular}
\end{table}

 Der zusätzliche analoge Ausgang des Flammensensors und des Mikrofons wird zur Messwertüberprüfung genutzt. Als einziger Sensor der Lichtsensor besitzt keine direkte Anschlussmöglichkeit an einen \ac{GPIO} Pin und kann somit nicht zusätzlich auf Messfehler untersucht werden. Der Aufbau der \ac{GPIO} Steckplatine beeinflusst zusätzlich die Pinbelegung der Sensoren. Wie in \fullref{fig:Kapitel2/gpio_pins_pi2.png} zu sehen ist, sind die Pins 9, 14, 20 und 25 Masseanschlüsse. Die genutzten Sensoren befinden sich in unmittelbarer Nähe zu diesen. Zum einen können sich Nutzer an den Positionen der Masseanschlüsse orientieren und zum anderen ebenfalls schneller den korrekten Pin finden. Ein weiterer Vorteil ist, dass im Falle eines versehentlichen Fehlanschließens keine Gefahr für den Sensor entsteht, da beispielsweise auf den digitalen Ausgangspin keine 5V Eingangsspannung gelangen kann. Durch die feste Pinbelegung entsteht eine feste Vorgabe der Anschlussarchitektur. Die Sensoren können falsch angeschlossen werden und würden dabei ebenfalls Messdaten erzeugen, doch eine korrekte Zuweisung der Messdaten an die Sensoren wäre nicht möglich. Des Weiteren hat die feste Pinbelegung ebenso einen Einfluss auf die Implementierung der Sensoren. 
\subsection{Implementierung der Sensoren}
%TODO: Alles erklären ...
% Lichtsensor: Problematisch ist hierbei das Tageslicht, da es das gleiche Verhalten beim Sensor auslöst.
% Schocksensor:Eine Umsetzung mit diesem Modell ist nicht mögich, da eine starke Erschütterung zum detektieren benötigt.
Bevor die Sensoren implementiert werden können, muss eine Softwarearchitektur aufgebaut werden. Zuerst gibt es die Auswahl eines objektorientierten oder nicht objektorientierten Ansatzes.
%TODO: Quelle raussuchen! 
Ein Vorteil der \ac{OOP} ist die Erweiterungsfähigkeit. Eine neue Funktion kann in der Klasse niedergeschrieben werden und zur Laufzeit ausgeführt werden. Des Weiteren können mehrere Instanzen einer Klasse zur Laufzeit erzeugt werden. Somit kann eine Hauptklasse erstellt werden, die dann zur Laufzeit mehrere Objekte erzeugen kann, die jeweils eine eigene Funktionalität ausüben. Eine weitere Problemstellung in der Entwicklung der Softwarearchitektur ist die Klassenhierarchie. Statt den gewöhnlichen Ansatz einer Hauptklasse und dann jeweils einer Unterklasse mit einer Funktionalität auszubauen, wird hierbei der Ansatz einer monolithischen Architektur gewählt. Im Sensorknoten werden nur Sensoren implementiert. Damit würde es eine Überklasse geben, wovon jeder Sensor erben würde. Beim monolithischen Ansatz gibt es nur eine Klasse, die alle Methoden enthält. Erst bei der Initialisierung kann entschieden werden, welche Funktion ausgeführt werden soll. Eine Instanz einer monolithischen Klasse kann somit, falls es einen Anlass dafür gibt, unabhängig von der Initialisierung ihre Funktionsweise wechseln. Beim klassischen objektorientierten Ansatz müsse eine komplett neue Instanz erzeugt werden. Ein Nachteil der monolithischen Architektur ist die Anhäufung von Methoden in einer Klasse. Ab einem gewissen Grad wird die Klasse schwer wartbar, da zu viele Methoden kontrolliert werden müssen. Diese Größe der Klasse kann weitere Fehler, wie das nicht korrekte Bereinigen von Bugs mit sich bringen. Das größte Problem dieser Architektur ist die fehlerhafte Instanziierung eines Objektes. Zur Darstellung des Problems dient folgendes Programmbeispiel:

\begin{lstlisting}[caption=Fehlerhafte Instanziierung eines Sensorobjektes,frame=single,numbers=left,language=Python]
# Initialisierung des Mikrofons
 sensor1 = Sensor(5, A0, 18)
# Korrekte Ausführung des Mikrofonsensors
<@ \textcolor{green}{\Checkmark} @> sensor1.mikrofon()
# Versuchte Ausführung der der Flammensensor Funktion mit dem Mikrofonobjekt
<@ \textcolor{red}{\XSolid} @> sensor1.flammensensor() 
\end{lstlisting}
Wie in Zeile 2 zu sehen ist, wird ein Sensorobjekt, mit der Bezeichnung "'sensor1"', mit 3 Eingabeparametern initialisiert. Diese werden im späteren Verlauf weiter erläutert. Sensor1 kann jetzt jede Methode der Sensorklasse ausführen. Dei der Initialisierung wurden die festen Angaben eines Mikrofonsensors angegeben. Damit ist die Zeile 4 die einzig korrekte Ausführung für dieses Sensorobjekt. Die Fehlerprüfung durch den Compiler wird bei dieser Architektur nicht unterstützt. Wie in Zeile 6 zu sehen ist, kann die Flammensensorfunktion aufgerufen werden. Für den Compiler ist es ein korrekter Aufruf der Flammensensormethode, jedoch würde diese lediglich fehlerhafte Messdaten zurückgeben. Die Funktionsweise der Sensorklasse wir in den folgenden Schritten erläutert.

\subsubsection*{Der Konstruktor} \label{Methode:Konstruktor}
	Wie in anderen Programmiersprachen, wird ebenfalls in Python ein Konstruktor für das Objekt benötigt. Der Konstruktor initialisiert alle notwendigen Variablen für das Objekt der Klasse. Im Falle des Sensorknotens sieht der Konstruktor wie folgt aus:
	%TODO: Listingreferenz hinzufügen
	\lstinputlisting[caption=Konstruktor der Sensorklasse,frame=single,numbers=left,language=Python, firstline=10, lastline=26]{Quellcode/sensor.py} \label{LST:Konstruktor}

	\textsc{Eric Matthes} beschreibt in seinem Buch "Python crash course"\cite{1593276036} die Funktion \_\_init\_\_ als eine geschützte Funktionalität von Python. Der Zweck der doppelten Unterstriche seie die Abgrenzung von möglichen Namen, die ein Programmierer vergeben dürfe. Es ist üblich, dass einfache Unterstriche zum verbinden von mehreren Wörtern genutzt werden. Somit, weiß der Programmierer, dass diese besondere Funktion nicht anders verwendet werden darf. Eine weitere Auffälligkeit ist die 'self' Variable. Nach \textsc{Eric Matthes} müsse der Parameter an erster Stelle im Konstruktor stehen. Dieser seie für den Bezug auf das Objekt relevant. Das 'self' ist in der Funktionalität ähnlich wie das 'this' aus Java. Die weiteren Übergabeparameter haben folgende Bedeutung:
	\begin{description}
		\item[SEN\_ID] \hfill \\
			Die SEN\_ID ist die feste Nummer des Sensors. Die Nummerierung entstammt dem \fullref{Sensoren_Planung}. Hierbei hat der Temperatursensor die Nummer 1 und der Luftfeuchtigkeitssensor die Nummer 2. Die restlichen Sensoren werden entsprechend hochgezählt. Die SEN\_ID wird für die Zuordnung des Messwertes zum Sensor in der Datenbank benötigt. 
		\item[Analog\_PIN] \hfill \\
			Der Analog\_PIN Übergabeparameter wird für das Ansprechen des A/D-Wanderls benötigt. Die Angaben können aus der \fullref{tab:Pinbelegung} entnommen werden.
		\item[Digital\_PIN] \hfill \\
			Die Nummerierung der Digital\_Pins kann ebenfalls aus der \fullref{tab:Pinbelegung} gelesen werden. Die Angabe wird für Sicherheitsüberprüfungen und zum Auslesen von den digitalen Sensorwerten benutzt.
   	\end{description}
	Der Sensorname ermittelt mit Hilfe der "'socket"' Bibliothek den Namen des Betriebssystems. Damit wird der Name des Sensorknotens ermittelt. Dieser wird für die Zuweisung der Sensoren zum Sensorknoten in der Datenbank genutzt. Der eigentliche Name des jeweiligen Sensors ist für den Sensorknoten nicht von Bedeutung, denn die SEN\_ID ist immer eindeutig. Der Name des Sensors wird mit Hilfe der Datenbank bestimmt.
	%TODO: Verknüpfung zur Zentraleinheit : Datenbank. Übersetzung SEN_ID zum Sensornamen
	Neben der SEN\_ID ist der Messwert in der zu übertragenden Nachricht an die Zentraleinheit enthalten. Der Messwert wird zu Beginn als ein leerer String vorgeladen. Python setzt keine Deklaration vor der Nutzung einer Variable voraus. Die Messwertvariable wird dennoch deklariert, damit der Quellcode wartbarer wird. Die Status Variable dient als Zustandskontrolle des Sensors. Der Status des Sensors wird auf der Webseite wie im Kapitel BLAARRRGH %TODO: Verweis auf Website Übersicht mit dem Statusbit!
	erläutert, dargestellt. Der Zustand ändert sich explizit, sobald ein Sensor detektiert wird. Die Status-Variable kann folgende Zustände annehmen:
	\begin{description}
		\item[Status = 0] \hfill \\
			Bedeutet, dass der Sensor nicht angeschlossen ist. Dies ist außerdem der Defaultzustand aller Sensorobjekte.
		\item[Status = 1] \hfill \\
			Bedeutet, dass der Sensor angeschlossen ist. Dieser Zustand soll dem Benutzer signalisieren, dass der Sensor korrekt arbeitet.
		\item[Status = 2] \hfill \\
			Bedeutet, dass der Sensor defekt ist. Anders als beim Zustand 0 tritt dieser Fall erst auf, wenn ein unmöglicher Messwert gemessen wurde. Ein Beispiel hierfür ist: Falls der Temperatursensor, welcher einen Messbereich von 0 bis 50$^\circ$C hat, Messwerte unter dem Gefrierpunkt oder über 50$^\circ$C liefert.
	\end{description}
	%TODO: REFERENZ RICHTIG MACHEN!
	In Zeile neun des \fullref{LST:Konstruktor} dient zur Einstellung der GPIO-Pinbezeichnung. \textsc{MATT} beschreibt in seinem Blogeintrag "'Simple Guide to the RPi Header and Pins'"\cite{SimpleGu6:online}, dass es zwei mögliche Modi für diesen Befehl gebe. Zum einen gibt es den Übergabeparameter "'GPIO.BOARD"' und zum anderen "'GPIO.BCM"'. Sie würden für die verschiedenen Nummerierungsmöglichkeiten der \ac{GPIO} Schnittstelle stehen. GPIO.BOARD würde die Nummerierung der Pins nach der Position auf dem Board durchführen. Im Gegensatz dazu nutze die GPIO.BCM Nummerierung die eigentliche GPIO Pinbelegung. Diese wir in der \fullref{fig:Kapitel2/gpio_pins_pi2.png} dargestellt.\\
	Die Ausgabe von Warnungen der GPIO Bibliothek wird mit dem Befehl in der zehnten Zeile deaktiviert. Diese sind nicht notwendig, da zum einen die Sensorenknoten an keiner graphischen Ausgabe angeschlossen sind und zum anderen Fehler separat behandelt werden.\\
	Falls der Sensor einen digitalen Anschluss hat, muss dieser initialisiert werden. Dazu dient die Kontrollstruktur von Zeile elf bis vierzehn. \textsc{Chris Hager} beschreibt in der "RPIO 0.10.0 documentation - RPIO, the Python module" den Befehl "GPIO.setup()"\space wie folgt: Der Befehl benötige als Übergabeparameter den Pin, den Modus - entweder GPIO.IN oder GPIO.OUT - die Angabe, ob der Pull-up oder Pull-down Widerstand aktiv sein solle. Im Falle der Sensoren muss das Signal als "GPIO.IN" deklariert werden. Es wird weder ein Pull-up noch ein Pull-down Widerstand angeschlossen. Aus diesem Grund wird als letzter Parameter "'GPIO.PUD\_OFF"' angegeben. \\
	Die letzten zwei Befehle dienen zum Initialisieren des I$^2$C Buses. Der '"smbus.SMBus(X)"' nimmt entweder den Wert 0 oder Wert 1 an. Nach einem empirischen Test hat es sich herausgestellt, dass die Raspberry Pis in der Version 2 und 3 das i2c-dev1 Interface standardmäßig nutzten. Somit muss der Befehl "'smbus.SMBUS(1)"' ausgeführt werden. Die Adresse des I$^2$C Ports muss ebenfalls angegeben werden. Nach dem Blogeintrag "GPIO Interface library for the Raspberry Pi"\cite{I2CPCF8592:online} von Wiring Pi seie die Adresse "0x46$_H$"\space die Standardadresse des I$^2$C Ports im Raspberry Pi. Damit ist der Konstruktor abgeschlossen und es folgen die Methoden der Sensorklasse.
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Bis hier hin gelesen und bewertet
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Aufräumfunktion}
	Diese Funktion dient zum Aufräumen der \ac{GPIO} Anschlüsse. \textsc{Ben Croston} schreibt in seinem Artikel "'RPi.GPIO basics 3"' \cite{RPiGPIOb90:online}, dass die \ac{GPIO} Pins aufgeräumt werden sollten. Folgendes Problem bestehe beim Raspberry Pi. Falls in ein Port im Programm auf auf den Wert "'1"' gesetzt wurde behalte dieser den Wert ebenfalls nach dem Beenden des Programms. Würde der Nutzer versehentlich Anschluss mit einem Masseanschluss verwinden, so wäre es möglich, dass die Platte durch den Kurzschluss Schäden davon trage. Die Implementierung für die Sensorklasse sieht wie folgt aus:
	\lstinputlisting[caption=Portbereinigungsmethode mittels GPIO.cleanup,frame=single,numbers=left,language=Python, firstline=28, lastline=29]{Quellcode/sensor.py}
	Nach \textsc{Ben Croston} \cite{RPiGPIOb90:online} reinige die GPIO.cleanup Funktion nur die verwendeten Ports des jeweiligen Objektes. Somit muss diese Funktion von jeweiligen Sensorobjekten ausgeführt werden. Semantisch gesehen gehört die Funktion in die Sensorklasse, dennoch befindet sie sich eine Abstraktionsstufe über dieser. Die Pins können erst aufgeräumt werden sobald ein Sensorobjekt nicht mehr gebraucht wird. Damit kommt diese Funktion erst zur Geltung, nachdem das Hauptprogramm, wie in REFERENZHAUPTPROGRAMM zusehen,
	%TODO: REFERENZ Auf StartSensor.py hier reinhauen!
	beendet wurde.
\subsubsection*{Bindung der Eventsteuerung des Flammensensors und des Mikrofons}
	Der Flammensensor unterscheidet sich in seinem Verhalten nicht vom dem Mikrofon. Da beide ein Auslösesignal zur Detektion eines Ereignisses benötigen, werden die Funktionen zusammengefasst dargestellt. Das folgende Listing stellt die Implementierungen der Eventsteuerung dar.
	\lstinputlisting[caption=Hinzufügen der Eventsteuerung für den Flammensensor und das Mikrofon,frame=single,numbers=left,language=Python, firstline=31, lastline=41]{Quellcode/sensor.py}
	Die GPIO Bibliothek bietet mit der Funktion "'add\_event\_detect"' eine Möglichkeit eigene Flankentriggerungen zu implementieren. Der Befehl benötigt die Angabe des Digitalen Pins, welche Flanken detektiert werden sollen, den darauffolgenden Methodenaufruf und zum Schluss Wiederholzeit. Der digitale Pin wird mit der Angabe "'Digital\_Pin"', wie im \fullref{Methode:Konstruktor} angegeben, festgelegt. Die GPIO Bibliothek unterstützt mit dem Parameter "'GPIO.RISING"' die steigende Flanke, mit "'GPIO.FALLING"' die fallende Flanke und "'GPIO.BOTH"' beide Flanken zu detektieren. Zur Ermittlung eines Ereignisses genügt die steigende Flanke eigentlich schon aus. Damit wäre der Ablauf des Programms gefährdet. Denn sobald ein Ereignis festgestellt wurde, wäre das Programm nicht in der Lage diesen gesetzten Zustand zu verlassen. Dafür werden beide Flanken betrachtet. Die fallende Flanke löst das zurücksetzen des Flags aus und zeigt damit dem Benutzer, dass das Problem beseitigt wurde. Ohne die fallende Flanke wäre die einzige Möglichkeit des Zurücksetzens ein Neustart des Programms. Die Angabe des "'callbacks"' legt die auszuführende Funktion bei einer Flankendetektion fest. Der letzte Parameter ist eine Analogie zum Prellverhalten von mechanischen Tastern. Damit kann eine Sperre in Millisekunden angegeben werden. Es soll eine Dopplung des Signals verhindern.
\subsubsection*{Eventsteuerung des Flammensensors und des Mikrofons}
	Nachdem die Vorbedingungen für die Eventsteuerung gelegt sind, kann die eigentliche Implementierung fortgeführt werden. Folgender Programmausschnitt verdeutlicht diese.
	\lstinputlisting[caption=Implementierung Eventsteuerung des Flammensensors und des Mikrofons,frame=single,numbers=left,language=Python, firstline=52, lastline=81]{Quellcode/sensor.py}
	Die erste Auffälligkeit dieser Methode ist der "'null"' Übergabeparameter. Dieser Hat seinen Ursprung in der callback Funktion vom vorherigen Unterthema. Der callback Funktionsaufruf benötigt übergibt immer einen Wert an seine Funktion. In diesem Fall wird kein Übergabeparameter vorausgesetzt, da die Funktion die Berechnungen durchführen soll. Die im \fullref{Methode:Konstruktor} beschriebene Statusvariable wird beim eintritt in die Funktion auf den Wert "'Angeschlossen"' gesetzt. Diese Funktion wird nur aufgerufen, wenn eine Flanke detektiert wurde. Somit muss der Sensor erstmals als funktional angesehen werden. Ob der Sensor fehlerfrei arbeitet, wird im späteren Verlauf festgestellt. Bevor das analoge Signal ausgelesen werden kann, muss der \ac{A/D-Wandler} angesprochen werden. Der Befehl in der dritten Zeile schreibt die Werte des Busses an der $I^2C$ Adresse an den eingestellten analogen Pin. Im nächsten Schritt wird der gemessene Analoge Wert in abgespeichert. Der digitale Wert wird mittels "'GPIO.input"' eingelesen. Mit diesem wird ermittelt, ob es sich um eine steigende oder um eine fallende Flanke handelt. Abhängig von der Flanke, wird entweder ein positives oder ein negatives Signal an die Zentraleinheit versendet. Falls der digitale Wert "'1"' ist, handelt es sich bei der vorliegenden Flanke um eine steigende. Durch empirische Untersuchungen wurde festgestellt, dass der Flammensensor und das Mikrofon beim Defekt einen Wert von "'255"' liefern. Der Wert entspricht einem Kurzschluss des Sensors. Nachdem sichergestellt wurde, dass der Sensor korrekt arbeitet, werden die Daten für die Zentraleinheit vorbereitet. Die notwendigen Daten werden in Form von einem \ac{JSON} Objekt versendet. Bei einer korrekten Messung liegt der Messwert "'TRUE"', bei einer nicht erfolgreichen Messung "'FALSE"' und beim defekt der Messwert "'0"' vor. Die unterschiedlichen Werte lösen verschiedene visuelle Darstellungen auf de Webseite aus. Dazu mehr im Kapitel
	%TODO: Referenz auf Übersichtsseite der Webseite
	dsadasölasd.
\subsubsection*{Sensorüberprüfung} \label{Sensorueberpruefung}
	In dieser Funktion wird überprüft, ob der angeschlossene analoge Sensor korrekt arbeitet. Durch empirische Untersuchung wurde festgestellt, dass der vorliegende \ac{A/D-Wandler} einen nicht angeschlossenen analogen Sensor mit einem Messwert von "'0"' angibt. Diese Information wird für die weitere Überprüfung genutzt. Die Umsetzung sieht wie folgt aus:
	\lstinputlisting[caption=Überprüfung ob analoger Sensor angeschlossen ist,frame=single,numbers=left,language=Python, firstline=83, lastline=91]{Quellcode/sensor.py}
	Python liefert im Falle eines nicht initialisiertem \ac{A/D-Wandler} einen "'IOError"' Fehler, der auf ein nicht angeschlossenes Eingabe- oder Ausgabegerät hinweist. Der Fehler wird abgefangen und stattdessen wird der Wert "'False"' übergeben. Dieser symbolisiert, dass kein analoger Sensor angeschlossen ist. Wie zuvor erwähnt gibt der \ac{A/D-Wandler} den Wert "'0"' als Referenz auf einen nicht angeschlossenen Eingang. Die hierbei vorliegenden analogen Sensoren haben, sobald sie angeschlossen sind, einen kleinen Betriebspegel, der im Leerlauf im Bereich 5 - 10 liegt. Falls der Pegel größer 0 ist, wird angenommen, dass der Sensor angeschlossen ist. Ansonsten wird angenommen, dass kein analoger Sensor angeschlossen ist.
\subsubsection*{Der Flammensensor und das Mikrofon}
	Da sowohl das Mikrofon als auch der Flammensensor exakt gleich aufgebaut sind, mit der einzigen Abweichung in Form des Sensors, ist die Funktionalität des Flammensensors gleich der des Mikrofons. Daher ist eine Erläuterung des Flammensensors ausreichend für das Verständnis der Mikrofonfunktion. Diese unterscheidet sich nur am Aufrufnamen, statt \textit{flammensensor()} wird \textit{mikrofon()} genutzt. Die folgende Erklärung bezieht sich auf den Quellcode des Flammensensors, dient aber ebenfalls für das Verständnis des Mikrofons. Beim Flammensensor werden die Messwerte des analogen Sensors ausgewertet und gegebenenfalls an die Zentraleinheit verschickt. Die Implementierung sieht wie folgt aus:
	\lstinputlisting[caption=Funktionsweise des Flammensensors,frame=single,numbers=left,language=Python, firstline=92, lastline=127]{Quellcode/sensor.py}
	Zu Beginn wird überprüft, ob der Sensor angeschlossen ist. Die Funktion "'sensorcheck\_analog()"', die im vorherigen \fullref{Sensorueberpruefung} erläutert wird, entscheidet, welches Paket an die Zentrale geschickt wird. Beim nicht angeschlossenem Sensor wird das Paket, mit den Werten Status und Messwert auf "'0"' gesetzt, abgeschickt. Falls ein Flammensensor angeschlossen ist wird eine weitere Unterteilung durchgeführt. Der digitale Pin wird auf eine logische "'1"' überprüft mit der Bedingung, dass der analoge Messwert "'Analog\_Wert"' unter 255 sein soll. Durch empirische Untersuchungen wurde festgestellt, dass der Flammensensor selbst bei maximaler Flammendetektion nicht auf den Messwert "'255"' beim A/D-Wandler ankommt. Somit eignet sich dieser Wert für die Vergewisserung der korrekten Funktionsweise des Flammensensors. Falls in der Zeile acht die Bedingungen erfüllt sind, muss der Flammensensor eine Flamme registrieren. Dazu wird der Messwert auf "'TRUE"' gesetzt und mit der senden Methode an die Zentrale verschickt. Die Sende Methode wird im späteren Verlauf erläutert. Falls der Flammensensor defekt ist und damit die Zeile 16 gültig, wird der Status auf "'2"' und der Messwert auf "'0"' gesetzt und ebenfalls an die Zentraleinheit abgeschickt. Falls keine Flamme am Flammensensor detektiert wird, besteht kein Bedarf eine Nachricht an den Server zu schicken. Der Server initialisiert die Webseite mit den Messwert "'FALSE"' für den Flammensensor.
\subsubsection*{Temperatur- und Luftfeuchtigkeitssensor}
	Der DHT11 Sensor liefert mit der Adafruit Bibliothek beide Werte gemeinsam aus. Aufgrund der Programmarchitektur, ein Objekt soll nur eine Funktion haben, wird die Funktionalität in zwei Methoden aufgeteilt. Aufgrund der hohen Ähnlichkeit der beiden Arbeitsweisen werden diese gemeinsam in einem Abschnitt erläutert. Der DHT11 Sensor ist einer der beiden Sensoren, der komplett ohne analoge Signale arbeitet. Wird ebenfalls die Kontrollmöglichkeit des Sensors eingeschränkt. Die Implementierung des Temperatursensors ist wie folgt:
	\lstinputlisting[caption=Implementierung der Temperaturfühlerfunktion des DHT11 Sensors,frame=single,numbers=left,language=Python, firstline=129, lastline=148]{Quellcode/sensor.py}
	Die Adafruit\_DHT Bibliothek liefert mit der Funktion "'read.retry()"' eine Möglichkeit den DHT11 Sensor auszulesen. Der erste Übergabeparameter für diese Funktion ist der Modulname des Sensors. Hierbei können Laut der Dokumentation der Adafruit DHT Bibliothek\cite{Adafruit47:online} "'11"', entsprechend dem DHT11, "'22"', entsprechend dem DHT22 und "'2302"', entsprechend dem AM2302 Sensor, angegeben werden. Nach der Angabe des Moduls folgt die Eingabe des verwendeten digitalen Pins. Die Funktion liefert als Rückgabewert ein Array mit zwei Speicherstellen. An der Stelle 0 wird die Luftfeuchtigkeit und an der Position 1 die Temperatur gespeichert. Dies hat zur Folge, dass in der Zeile 2 die Position "'1"' der Funktionsrückgabe gespeichert wird. Der digitale Sensor hat keine Möglichkeit eine unabhängige Fehlerüberprüfung zu gewährleisten. Daher wird zur Fehlerabhandlung der Messbereich des Sensors als Richtwert genommen. Falls die gemessene Temperatur außerhalb des festgelegten Bereiches liegt, wird angenommen, dass der Sensor defekt sein muss. Hier ist eben die einzige Unterscheidung zwischen der Temperaturmethode und der Luftfeuchtigkeitsmethode. Bei der Temperatur wird der Bereich 0 bis kleiner gleich 50$\circ$C , während die Luftfeuchtigkeit zwischen 0 und kleiner gleich 95\% gemessen werden kann. Sollte sich der Messwert im messbaren Bereich befinden, wird der Status auf eine "'1"' und der Messwert auf den gemessenen Wert gesetzt. Der Messwert muss jedoch zuvor vom Float-Datentyp in einen Text konvertiert werden, damit es keine Darstellungsprobleme auf der Webseite gibt. Falls kein DHT11 Sensor angeschlossen ist, wird die Funktion in der Zeile zwei kein Objekt "'temperatur"' erzeugen. Python besitzt die Fähigkeit auf nicht vorhandene Objekte in einer Kontrollstruktur zu prüfen. Damit wird die Zeile acht im Falle eines nicht vorhandenen Sensors erfüllt und die des Status und des Messwerts auf "'0"' gesetzt. Der else Pfad in der Zeile elf wird im Falle eines defekten Sensors ausgeführt. Bei einer Fehlfunktion würde entweder eine "'0"' oder ein sehr hoher Wert gemessen werden. Abschließend werden die Daten mittels der senden Funktion an den Server geschickt.
\subsubsection*{Der Lichtsensor}
	Beim Lichtsensor handelt es sich um einen analogen Photowiderstand, der abhängig von Helligkeit des Lichts, einen niedrigen oder hohen Widerstand besitzt. Dieser analoge Widerstandswert wird am A/D-Wandler in einen digitalen Messwert umgewandelt. Die Funktionalität ist wie folgt:
	\lstinputlisting[caption=Implementierung des Lichtssensors,frame=single,numbers=left,language=Python, firstline=207, lastline=233]{Quellcode/sensor.py}
	Da es sich bei dem Lichtsensor um einen analogen Sensor handelt, kann die "'sensorcheck\_analog()"' Funktion überprüfen, ob der Sensor angeschlossen ist. Der Messwertbereich der Kontrollstruktur in der Zeile fünf entscheidet ab welchem Lichteinfall der Sensor reagieren soll. Die Grenzen wurden empirisch festgelegt, da der Sensor keine weitere Möglichkeit hierfür bietet. Diese Grenzen sind abhängig von, Positionierung des Sensors, Tageszeit, allgemeiner Lichteinfall in dem Zimmer, mögliche Lichtquellen im Zimmer und der Zimmerfunktion. In einer Küche gibt es beispielsweise mehr Störquellen als in der Abstellkammer. Aus diesem Grund sollte der Sensor vor jeder Nutzung korrekt eingestellt werden. Der Lichtsensor stellt auf der Webseite entweder brennendes oder nicht brennendes Licht dar, daher ist die Information "'TRUE"' oder "'FALSE"' ausreichend für den Server. Der Status und der Messwert werden wie gehabt an den Server geschickt.
\subsubsection*{Lichtschranke und Schocksensor}
	Die Lichtschranke und der Schocksensor sind beide ereignisgesteuerten Sensoren, die mit einer Flankenerkennung arbeiten. Dazu wird die GPIO Funktion "'add\_event\_detect()"', die im \fullref{Methode:Konstruktor} erläutert wird, genutzt. Die Implementierung sieht wie folgt aus:
	\lstinputlisting[caption=Implementierung der Lichtschranke und des Schocksensors,frame=single,numbers=left,language=Python, firstline=235, lastline=242]{Quellcode/sensor.py}
	Ein Signal an einem der beiden Sensoren führt zur Ausführung der folgenden Funktion:
	\lstinputlisting[caption=Funktion der Flankenerkennung der Lichtschranke und des Schocksensors,frame=single,numbers=left,language=Python, firstline=43, lastline=50]{Quellcode/sensor.py}
	Bei beiden Sensoren ist lediglich die Auskunft, ob es eine Unterbrechung der Lichtschranke oder das Auslösen des Schocksensors gibt. Daher muss nur der Messwert "'TRUE"' an den Server gesendet werden.
\subsubsection*{Senden}
	Sämtliche Informationen der Sensorknoten müssen an den Server überbracht werden. Hierfür dient die "'senden()"' Funktion, die auf einer Socketschnittstelle basiert. Die Herangehensweise hierbei ist wie folgt:
	\lstinputlisting[caption=Implementierung der Sende Funktion Seitens des Sensorknotens,frame=single,numbers=left,language=Python, firstline=244, lastline=254]{Quellcode/sensor.py}
	Zu Erst muss ein Socketobjekt angelegt werden. Da der Sensorknoten die Rolle des Clienten hat, benötigt er zum Verbindungsaufbau die IP-Adresse und den Port des Servers. Exemplarisch dienen hierfür die Angaben in den Zeilen drei und vier. Eine fehlende Verbindung zum Server sollte den Programmfluss nicht terminieren lassen. Daher wird der Sendevorgang in einen try Block gekapselt, der einen Socketfehler erwartet. Sollte der Server nun nicht erreichbar sein wir die meldung "'Server nicht erreichbar!"' angezeigt und das Programm läuft weiter. Dieser Puffer vermeidet bei einer kurzen Unterbrechung zum Server ein kompletten Neustart des Sensorknotens. Der Sendevorgang geschieht wie folgt. Der Socket baut zunächst eine Verbindung zum Server auf. Danach übersendet es mit dem Befehl "'sendto()"' eine kodierte Nachricht an den Server. Hier wurde ein JSON Paket ausgewählt, dass mit der Kodierung "'utf-8"' kodiert ist. Wichtig ist hierbei, dass Seitens des Servers die gleiche Kodierung ausgewählt wird, da sonst die Nachricht nicht verwertet werden kann. 
\subsection{Konfiguration \& Testen der Sensoren}
%TODO: Unseren Code nochmal anschauen
\subsection{Priorisierung der Sensoren}
Der Hauptaspekt der Priorisierung ist die Sicherstellung, dass ein hoch priorisierter Messwert ohne Verzögerung ausgegeben wird.
%TODO: Vorgang des Messens erläutern
%TODO: Zeitkritische Abhängigkeiten erklären (messschleife beim DHT11)
%TODO: Eventgesteuerte Priorisierung
%TODO: Erweiterbarkeit
%TODO: Unsere Priorisierung erklären
%TODO: Übergang zur Übertragung!
\subsection{Übertragung der Sensordaten}
%TODO: Abstimmen mit jan - gleiche Struktur

%Jan
\section{Zentraleinheit}%Allgemein Vorinstallation!%verweis auf Planung Zentraleinheit
Damit die Zentraleinheit die Anforderungen, welche im \fullref{Planung} festgelegt wurden erfüllt, wurde folgende Software auf der Zentraleinheit vorinstalliert:
\begin{description}
	\item[MySQL] \hfill \\
	Eine MySQL Datenbankserver wurde auf der Zentraleinheit installiert, dieser dient wie im \fullref{sub:Datenbank} vorgestellt, dem Sammeln der Sensordaten. Mit den vorgestellten Programmiersprachen im \fullref{Python} und im \fullref{PHP} ist es möglich eine Verbindung zur Datenbank zu erstellen. Zusätzlich kann die Datenbank mit den zuvor erwähnten Sprachen befüllt und ausgelesen werden.
	%AUSFÜHREN MIT QUELLE WAS IST MySQL etc.
	\item[PhpMyAdmin] \hfill \\
	Zum einfacheren Erstellen und Testen, wurde eine PhpMyAdmin installiert. PhyMyAdmin ist eine grafische Oberfläche für den Webbrowser, mit der der Inhalt angezeigt und bearbeiet werden kann. Ebenso können Benutzerrechte festgelegt werden. Über die Oberfläche ist es möglich Cronjobs zu implementieren.
	%EVTL QUELLE
	\item[Apache2] \hfill \\
	Zur Darstellung, der im \fullref{sub:Webseite} geplanten Webseite, wurde ein Apache2 als Webserver installiert.
	%AUSFÜHREN MIT QUELLE WAS IST APACHE2 etc.		
\end{description}
\subsection{Empfangen der Sensordaten}
Die Scriptsprache Python muss mit folgenden Bibliotheken erweitert werden, damit eine Socketschnittstelle erstellt werden kann.
\begin{lstlisting}[caption=Einbinden der Bibliotheken für die Schnittstelle,frame=single,numbers=left,language=Python]
import socket
import json
\end{lstlisting}
Die Bibliotheken socket und json werden eingebunden. Die Bibliothek socket ist dafür zuständig, die funktionalität der Socketschnittstellt bereitzustellen. Die Bibliothek json ist in diesem Fall nur für die Codierung zuständig.\hfill
\noindent Nachfolgend sehen sie die Bereitstellung der Socketschnittstelle.
% Referenz Methode:senden
\begin{lstlisting}[caption=Bereitstellen der Socketschnittstelle,frame=single,numbers=left,language=Python]
s = socket.socket()
host = '192.168.178.1'
port = 12345
s.bind((host, port))
s.listen(5)
msg = 'Thank you for connecting'
\end{lstlisting}
Mit dem Befehl socket.socket()....

\begin{lstlisting}[caption=Speichern der Daten,frame=single,numbers=left,language=Python]
while True:
	c, addr = s.accept()
	print('Got connection from ', addr)
	data = json.loads(c.recv(4096).encode('utf-8'))
	Name = str(data["Name"])
	SEN_ID = str(data["SEN_ID"])
	Wert = str(data["Messwert"])
	adresse = str(addr[0])
\end{lstlisting}
\label{Daten}
\subsection{Befüllen der Datenbank}
Damit mit Python eine Datenbank befüllt werden kann, muss zuerst eine Bibliothek eingebunden werden.
\begin{lstlisting}[caption=Einbinden der Bibliothek für die Datenbank,frame=single,numbers=left,language=Python]
import MySQLdb as mdb
\end{lstlisting}
Die Bibliotheken MySQLdb wird einbunden und ihr Name in mdb geändert.\hfill
\noindent Danach muss der Datenbankkonnektor implementiert werden. Nachfolgenden der Quellcode für den Datenbankkonnektor.
\begin{lstlisting}[caption=Datenbankkonnekor,frame=single,numbers=left,language=Python]
try:
	con = mdb.connect('localhost', 'root', 'Piroot',
	'Sicherheitssystem')
	print("SQL-Connection successful")
except _mysql.Error, e:
	print("SQL-Connection failed. Error %d:
	%s" % (e.args[0], e.args[1]))
\end{lstlisting}
Der Datenbankkonnektor ist in zwei Blöcke unterteilt, dem try Block und dem except\_mysql.Error, e Block.

\noindent Im try Block wird über die Funktion mdb.connect eine Verbindung hergestellt und in der Variable con \label{con} gespeichert. Die in den Klammern stehenden Variablen sind v.l.n.r der Hostname, der Benutzername, das Passwort und die Datenbank die Angesprochen werden soll. Wenn die Verbindung fehlerfrei hergestellt wurde, wird über die print Funktion die Meldung "SQL-Connection successful" ausgegeben.

\noindent Im zweiten Block, dem except\_mysql.Error, e Block wird der Fehlerfall abgedeckt. Sollte die Funktion mdb.connect keine erfolgreiche Verbindung herstellen, gibt die print Funktion die Meldung "SQL-Connection failed. Error \%d:\%s" aus. An die Stelle des Platzhalters \%d wird der Fehlercode und an den Platzhalter \%s die Fehlermeldung die zurückgegeben wird geschrieben, die die Datenbank liefert.

Im nächsten Abschnitt ist der komplette Quellcode der eigentliche Befüllung der Datenbank zu sehen.
\begin{lstlisting}[caption=Befüllen der Datenbank,frame=single,numbers=left,language=Python]
with con:
	cur = con.cursor()
	row_count = cur.execute("SELECT KN_ID FROM Sensorknoten
	WHERE Knotennamen = %s", (Name,))
	# Wenn ein Datenbankeintrag gefunden wird,
	wird die IPv4-Adresse erneuert
	if row_count == 1:
		KN_ID = cur.fetchone()
		cur.execute("""UPDATE Sensorknoten SET
		IPv4_Adresse = %s WHERE
		Knotennamen = %s""", (adresse, Name))
		cur.execute("""INSERT INTO Messwerte 
		(SEN_ID, Messwert) VALUES(%s, %s)""",
		(SEN_ID, Wert))
		# Die zuletzt erstellte ID wird übergeben
		MessID = cur.lastrowid
		cur.execute("""INSERT INTO 
		Sensorknoten_Messwerte (KN_ID, MESS_ID)
		VALUES(%s, %s)""", (KN_ID, MessID))
		# Wenn kein Datenbankeintrag gefunden wird,
		wird ein neuer Datenbankeintrag erstellt
	elif row_count == 0:
		cur.execute("""INSERT INTO Sensorknoten
		(Knotennamen, IPv4_Adresse) VALUES
		(%s, %s)""", (Name, adresse))
		# Die zuletzt erstellte ID wird übergeben
		KN_ID = cur.lastrowid
		cur.execute("""INSERT INTO Messwerte
		(SEN_ID, Messwert)VALUES(%s, %s)""",
		(SEN_ID, Wert))
		# Die zuletzt erstellte ID wird übergeben
		MessID = cur.lastrowid
		cur.execute("""INSERT INTO 
		Sensorknoten_Messwerte(KN_ID, MESS_ID)
		VALUES(%s, %s)""", (KN_ID, MessID))
con.close()
\end{lstlisting}
Der große Block, beginnend mit with con und endend mit con.close(), beinhaltet die Befüllung der Datenbank. with con bedeutet, dass der nachfolgenden Quellcode mit dem Konnektor aus Kapitel \fullref{con} durchgeführt wird und das close.con(), dass die Verbindung getrennt wird. Im ersten Abschnitt wird mit dem Befehl con.cursor() ein Cursor-Objekt in der Variable cur gespeichert, dieses Cursor-Objekt wird dazu benötigt um die Datensätze in der Datenbank zu durchlaufen. Mit dem cur.execute Befehl werden die in der Select-Anweisung festgelegten Datensätze durchsucht und in die Variable row\_count gespeichert. Die Variable row\_count dient zur Auswertung, ob ein Datensatz vorhanden ist oder nicht.\hfill
\begin{lstlisting}[caption=If-Anweisung des Befüllen der Datenbank,frame=single,numbers=left,language=Python]
if row_count == 1:
	KN_ID = cur.fetchone()
	cur.execute("""UPDATE Sensorknoten SET
	IPv4_Adresse = %s WHERE
	Knotennamen = %s""", (adresse, Name))
	cur.execute("""INSERT INTO Messwerte 
	(SEN_ID, Messwert) VALUES(%s, %s)""",
	(SEN_ID, Wert))
	# Die zuletzt erstellte ID wird übergeben
	MessID = cur.lastrowid
	cur.execute("""INSERT INTO 
	Sensorknoten_Messwerte (KN_ID, MESS_ID)
	VALUES(%s, %s)""", (KN_ID, MessID))
\end{lstlisting}\label{If-Anweisung}
\noindent In der If-Anweisung wird überprüft ob ein Datensatz vorhanden ist, ist ein Datensatz vorhanden, springt das Programm in den nachfolgenden if Block.In diesem Block wird zuerst die zuvor selektierete Knotenid mit dem Befehl cur.fetchone() geholt und in die Variable KN\_ID gespeichert. Danach wird mit den Daten aus Kapitel \fullref{Daten} der Datenbankeintrag mit dem SQL-Befehl UPDATE erneuert. Mit dem SQL-Befehl INSERT wird ein neuer Datensatz in der Datenbanktabelle Messwerte erzeugt. Die ID des zuletzt erstellten Datenbankeintrag wird mit dem Befehlt cur.lastrowid in die Variable MessID gespeichert. Diese MessID wird benötigt, damit die Verknüpfung der Datenbank Tabellen mit dem nächsten Befehlt stattfinden kann. Der letzte INSERT-Befehlt verknüpft die Datenbanken, dies ist wichtig für die spätere Suche nach den richtigen Werten für die Anzeige auf der Webseite. 
\begin{lstlisting}[caption=Ifelse-Anweisung des Befüllen der Datenbank,frame=single,numbers=left,language=Python]
	# Wenn kein Datenbankeintrag gefunden wird,
	wird ein neuer Datenbankeintrag erstellt
elif row_count == 0:
	cur.execute("""INSERT INTO Sensorknoten
	(Knotennamen, IPv4_Adresse) VALUES
	(%s, %s)""", (Name, adresse))
	# Die zuletzt erstellte ID wird übergeben
	KN_ID = cur.lastrowid
	cur.execute("""INSERT INTO Messwerte
	(SEN_ID, Messwert)VALUES(%s, %s)""",
	(SEN_ID, Wert))
	# Die zuletzt erstellte ID wird übergeben
	MessID = cur.lastrowid
	cur.execute("""INSERT INTO 
	Sensorknoten_Messwerte(KN_ID, MESS_ID)
	VALUES(%s, %s)""", (KN_ID, MessID))
\end{lstlisting}
\noindent Wenn kein Datensatz gefunden wurde, springt das Programm in die Elseif-Anweisung.Diese Elseif-Anweisung funktioniert ähnlich wie die zuvor vorgestellte If-Anweisung aus Kapitel \fullref{If-Anweisung}, sie unterscheidet sich ausschließich in den ersten paar Zeilen. Anstatt wie zuvor den mit Hilfe der Knotenid selektierte Datensatz zu erneuern, wird hier ein neuer Datensatz mit den Daten aus Kapitel \fullref{Daten} erstellt. Die Kontenid des zuvor erstellten Datensatz wird mit dem Befehl cur.lastrowid in die Variable KN\_ID für einen späteren SQL-Befehl gepseichert. Mit dem SQL-Befehl INSERT wird ein neuer Datensatz erstellt, dieser enthält Werte aus dem \fullref{Daten}. Auch hier wird wieder die ID, in diesem Fall die MessID, des zuvor erstellten Datensatzes in die Variable MessID gespeichert. Die letzte INSERT-Anweisung, verknüpft die Datenbanken mit Hilfe der zuvor gespeicherten ID's, KN\_ID und MessID.   
\subsection{Problematik Zeitsynchronisierung}
 
\section{Webseite}
%Harm
\subsection{Login und Logout}

Der Login, die Registrierung und der Logout ist nach der Anleitung von
wikiHow (\cite{PHP-Login}) erstellt und entsprechend angepasst worden. 
\\
Der Login besteht aus mehreren Dateien, deren Funktion in der Tabelle
(\nameref{tab:Login-Dateien}) aufgezählt ist.

\begin{table}
\caption{PHP-Login-Dateien und Funktion}
\label{tab:Login-Dateien}
\begin{tabular}{p{0.5\textwidth} p{0.45\textwidth}}
\textbf{Datei} 				& \textbf{Erklärung} \\
Login.php 						& Die Loginseite - Gleichzeitig auch die Startseite bei Aufruf der Server-IP\\
Register.php 					& Die Registrierungsseite \\
Register\_success.php & Die Seite, die nach einer erfolgreichen Registrierung angezeigt wird \\
Logout.php 						& Die Seite, die nach einem erfolgreichen Logout angezeigt wird \\
psl\_config.php 			& Festlegung von Variablen, die mehrfach verwendet werden \\
db-connect.php 				& Datenbank-Connector \\
functions.php 				& Relevante Funktionen, die benötigt werden \\
process\_login.php 		& Code der die Logindaten der Loginseite überprüft und danach auf die Übersichtsseite weiterleitet \\
register\_inc 				& Code der abläuft wenn sich ein User neu registriert \\
forms.js 							& Javascriptdatei, für das Hashen und Überprüfen der Passwörter \\
sha512.js 						& Hashfunktion nach Standard SHA-512 \\
style.css 						& CSS-Datei für zentrale Designeinstellungen \\
 \end{tabular}
\end{table}

In der Datei functions.php sind zentrale Funktionen gesammelt, die nachfolgend
beschrieben werden:

\subsubsection{sec\_session\_start}
%TODO: Session-ID und Cookie erklähren - Erledigt?
Diese Funktion vergibt eine Session-ID und legt fest, dass Cookies verwendet werden. Die Session-ID ermöglicht es Anfragen eines Clients zuordnen zu können und Antworten oder Aktualisierungen an diesen zu senden. Die Session-ID wird vom Server generiert und per Cookie an den Client übertragen. Der Client speichert das Cookie ab und sendet bei jeder Anfrage das Cookie (mit der Session-ID) an den Server. Wird keine oder eine falsche Session-ID übertragen erhält der Benutzer, die Meldung, dass er sich zuerst am System anmelden muss. Durch den Anmelde-Vorgang wird dem Client eine neue Session-ID zugewiesen.

\subsubsection{login}
Diese Funktion steuert alle notwendigen Abläufe, die den Login betreffend.\\
Aufgerufen wird die Funktion mit den Parametern Username, Passwort und der Datenbankverbindung. Die Parameter Username und Passwort werden aus POST-Werten der Loginseite übergeben während die Datenbankverbindung in der Datei db-connect.php definiert ist. Durch ein Prepared-Statement werden die benötigten Werte aus der Datenbank abgerufen. Danach wird verglichen ob der übergebene Username in der Datenbank hinterlegt ist. Existiert der Benutzer, wird zuerst durch die Funktion 'checkbrute' überprüft, ob der Benutzer momentan gesperrt ist. Ist der Benutzer nicht gesperrt, wird das Passwort überprüft und der Anwender wird auf die Seite 'Übersicht' weitergeleitet. Ist das Passwort nicht korrekt, wird der fehlgeschlagene Loginversuch in der Datenbank vermerkt und der Benutzer erhält eine Meldung, dass der Anmeldeversuch fehlgeschlagen ist. 

\subsubsection{checkbrute}

\subsubsection{login\_check}
Diese Funktion prüft ob ein Anwender eingeloggt ist und setzt den entsprechenden
Parameter, der entscheidet was der Anwender auf der Website sieht.

\subsubsection{esc\_url}

%Jan
\subsection{Übersicht}
Die Übersichtsseite zeigt einen Übersicht über die angeschlossenen Sensorknoten und die Werte der einzelnen Sensoren der Sensorknoten an. Auf der Webseite werden nur die Sensorknoten mit ihren Sensoren angezeigt die sich tatsächlich im Netz befinden. Dafür zuständig ist die Datei sensordaten.php. Die Datei sensordaten.php ladet die Werte aus der Datenbank und erstellt daraus dynamisch eine Anzeigetabelle der Sensorknoten und den zugehörigen Sensoren. Die Anzeigetabelle zeigt alle Sensoren an die an den jeweiligen Sensorknoten angeschlossen sind, falls Sensoren nicht angeschlossen sind, wird das in der Tabelle angezeigt. Zusätzlich wird unter jede Tabelle ein Symbol mit der Verlinkung zu den Statistiken(siehe \fullref{Statistik}) und der Webkameras(siehe \fullref{Webkamera}) angezeigt, dies hat den Zweck zum schnelleren wechsel auf die jeweilige Seite.Des weiteren wird die Seite alle fünf sekunden automatisch nachgeladen, dies geschieht über die uebersichtscript.js und sorgt dafür, dass die angezeigten Daten aktuell sind ohne die Seite manuell zu aktualisiert werden.

%Alex
\subsection{Statistik}\label{Statistik}
%Alex+Jan
\subsection{Webkamera}\label{Webkamera}
%Harm
\subsection{Impressum}

Auf der Seite "`Impressum"' stehen die Namen der drei Autoren, der Titel des Projektes und diese Dokumentation wird zum Download angeboten. Ansonsten ist keine weitere Funktionalität implementiert.
%Alle
\section{Refactoring}
%Alle
\section{Systemtest}
