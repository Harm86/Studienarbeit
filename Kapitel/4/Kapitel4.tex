\chapter{Umsetzung}

Die Sensoren werden an einen Raspberry Pi angeschlossen und melden die
gemessenen Werte an einen zentralen Raspberry Pi. Der zentrale Raspberry Pi legt
die gemeldeten Daten in einer Datenbank ab. Eine Website greift auf die
Datenbank zu und stellt die Daten dar.\\
Die Kommunikation wird über ein eigenes WLAN-Netz abgewickelt das von der
Zentraleinheit aufgespannt wird. IP-Adressen werden von einem \ac{DHCP}-Server, der
auf der Zentraleinheit installiert ist vergeben.\\
Die Website wird durch einen Apache-Webserver auf der Zentraleinheit
bereitgestellt.

%Harm
\section{Netzwerkkonfiguration}
%TODO: Einleitender satz
%TODO: WLAN-Stick
%TODO: Acro WLAN Anmerkung: WLAN ist eine allgemein bekannte Abkürzung und muss nicht erklärt werden!!
\subsection{WLAN}
%TODO: Wird von der Zentraleinheit aufgespannt
Es wird ein Funknetz auf Basis des 802.11n Standards verwendet. Aufgespannt wird das WLAN von der Zentraleinheit, auf der zentrale Dienste bereitgestellt werden. Als Name wurde Pinet festgelegt, der von allen gesehen werden kann. In der Tabelle (\nameref{tab:WLAN-Konfiguration}) sind die einzelnen Optionen aufgeführt und erläutert.

 
\begin{table}
\caption{WLAN-Konfigurationsdetails}
\label{tab:WLAN-Konfiguration}
\begin{tabular}{p{0.5\textwidth} p{0.45\textwidth}}
\textbf{Befehl} 						& \textbf{Erklärung} \\
interface=wlan0 						& Das Interface auf dem das Funknetz ausgestrahlt wird \\
ssid=Pinet 									& Der Name des Funknetzes \\
country\_code=DE 						& Über die Festlegung der Region wird sichergestellt, dass das Funknetz die spezifischen Grenzwerte für Kanäle oder Sendestärke einhält \\
hw\_mode=g 									& Legt fest, dass das Funknetz im 2,4 GHz-Band ausgestrahlt wird \\
channel=6 									& Der Funkkanal 6 wird verwendet \\
macaddr\_acl=0 							& MAC-Adressenfilterung ist deaktiviert \\
auth\_algs=1 								& Legt fest, dass als Verschlüsselung \ac{WPA} verwendet wird \\
ignore\_broadcast\_ssid=0 	& Die \ac{SSID} wird ausgestrahlt und nicht versteckt. \\
wpa=2 											& Legt die WPA-Version fest auf \ac{WPA2} \\
wpa\_passphrase=********** 	& Legt den \ac{PSK} fest \\
wpa\_key\_mgmt=WPA-PSK 			& Legt fest, dass ein \ac{PSK} verwendet wird \\
wpa\_pairwise=CCMP 					& Legt fest, dass nur der \ac{AES}-Verschlüsselungsalgorithmus verwendet wird \\
wpa\_group\_rekey=86400 		& Legt fest, dass alle 86400 Sekunden ein neuer Schlüssel verwendet werden muss \\
ieee80211n=1 								& Aktiviert den n-Standard \\
wme\_enabled=1 							& Aktiviert \ac{QoS} - Voraussetzung für die Verwendung des n-Standards \\
 \end{tabular}
\end{table}

\subsection{Verschlüsselung}

Wie aus der Tabelle WLAN-Konfigurationsdetails (\nameref{tab:WLAN-Konfiguration}) hervorgeht ist das WLAN mit \ac{WPA2} verschlüsselt. \ac{WPA2} gilt aktuell als sicher, was nicht für die Alternativen \ac{WEP} oder \ac{WPA} gilt. Zur Authentifizierung wird ein \ac{PSK} verwendet. Als Verschlüsselungsprotokoll wird \ac{CCMP} verwendet. 


\subsection{\ac{DHCP}}
 
Als \ac{DHCP}-Server wird der ISC-DHCP-Server verwendet.\\
Die IP-Adressen werden nur über das wlan0-Interface der Zentraleinheit vergeben. Als Netz wurde das Private Netz 192.168.178.0 /24 verwendet. In diesem Netz hat die Zentraleinheit als \ac{DHCP}-Server die Adresse 192.168.178.1 /24. Diese Adresse ist Statisch eingetragen. Alle anderen Geräte erhalten dynamische IP-Adressen aus dem Bereich 192.168.178.10 - 192.168.178.250. Die Lease-Time wurde auf 604800 sekunden festgelegt. Dies entspricht 7 Tagen. Als Lease-Time wird der Zeitraum bezeichnet, in dem ein Netzwerkgerät, die gleiche IP-Adresse erhält. So wird verhindert, dass viele Adressänderungen stattfinden. Da nur wenige Geräte im Netz verfügbar sind und auch keine häufigen Änderungen erwartet werden wird der Zeitraum von 7 Tagen als ausreichend angesehen. Damit der \ac{DHCP}-Server die IP-Adressen nur im WLAN vergibt wurde die IP-Adress-Vergabe auf das Interface wlan0 eingeschränkt.
%TODO: Kästchen aus um den Quellcode!


\begin{lstlisting}[caption=Konfiguration des ISC-DHCP-Server,frame=single]
#Rogue-DHCP-Server nicht erlauben (Doppelter DHCP-Server)
authoritative;

#Definition des Subnetzes
subnet 192.168.178.0 netmask 255.255.255.0
{
        #Angabe der DHCP-Range
        range 192.168.178.10 192.168.178.250;

        #Angabe der Lease-Times 7 Tage in sekunden
        default-lease-time 604800;
        max-lease-time 604800;

        #Begrenzung auf das WLAN-Interface
        interface wlan0;
}

\end{lstlisting}

%Alex
\section{Sensorknoten} %Allgemein Vorinstalation!
Für die Umsetzung des Sensorknotens werden vorab Pythonbibliotheken benötigt. Sie werden mit dem folgenden Befehl im Quellcode hinzugefügt:
\begin{lstlisting}[caption=Importbefehl in Python,frame=single,numbers=left,language=Python]
# Hinzufügen eines kompletten Paketes
import <Paketname> as <Aliasname>
# Hinzufügen einer Methode aus einem Paket
from <Paketname> import <Methodenname>
\end{lstlisting}
Die benötigten Pakete sind wie folgt: \\
'RPi.GPIO', 'smbus', 'socket', 'json' und 'Adafruit\_DHT'. RPi.GPIO ist die Bibliothek zur Nutzung der \ac{GPIO} Schnittstelle in Python. Das Paket smbus ermöglicht den Zugriff auf die I$^2$C Schnittstelle. Das Paket socket ermöglicht die Nutzung der TCP/IP Socketverbindung. Mittels json kann das Datenformat \ac{JSON} genutzt werden. Python bietet mit Hilfe der Adafruit\cite{Adafruit60:online} Bibliotheken eine Schnittstelle zu den Sensoren. Die Adafruitbibliothek kann mit Hilfe des pythoneigenen Paketmanagers, "'pip"', installiert werden.
\begin{lstlisting}[caption=Installation der Adafruit Bibliothek mit pip,frame=single]
pip install adafruit_python_dht
\end{lstlisting}
Dieses Paket wird zum Ansteuern des DHT-11 Sensors, der im \fullref{Sensoren_Planung} beschrieben wird, benötigt. Die genutzte Erweiterungsplatine RPI - Explorer 700 benötigt keine zusätzliche Software. Die Platine muss fest auf die \ac{GPIO} Pins gesteckt werden, um funktional zu sein. Der \ac{A/D-Wandler} befindet sich neben den \ac{GPIO} Anschlüssen und hat eine gelbe Platinenfarbe. Bevor der \ac{A/D-Wandler} einsatzfähig ist muss der I$^2$C Bus in der Raspi-config Datei aktiviert werden. Mit dem aktiven I$^2$C Bus können die Sensoren angeschlossen werden.
\subsection{Verdrahtung der Sensoren}\label{Verdrahtung_der_Sensoren}
%Die Sensoren werden bestimmten Pins zugewiesen, damit sowohl erfahrene als auch unerfahrene Nutzer dieses Sensorknotensystem nachbauen können.
Die Sensoren, aus dem \fullref{Sensoren_Planung}, haben eine feste Zuweisung an die jeweiligen Pins, damit andere Nutzer das System einfacher und schneller nachbauen können, ohne Probleme bei der Verbindung der Sensoren zu bekommen. Die Pins sind wie folgt belegt:
\begin{table}[htp]
	\caption{GPIO und analoge Pinbelegung der Sensoren}
	\label{tab:Pinbelegung}
	\subcaption*{GPIO Pinbelegung}
	\begin{tabular}{p{0.15\textwidth} p{0.2\textwidth} p{0.6\textwidth}}
		\textbf{GPIO-Pin}	& \textbf{Sensor} & \textbf{Beschreibung} \\
		Pin 5 		& Schocksensor 	& Funktionsweise über die Flankendetektion\\	
		Pin 17		& Flammensensor	& True oder False Wert vom Sensor\\
		Pin 18		& Mikrofon		& True oder False Wert vom Sensor\\
		Pin 24		& Lichtschranke	& True oder False Wert vom Sensor\\
		Pin 25		& DHT11 Sensor	& Luftfeuchtigkeits- und Temperaturwerte werden als digitale Werte geliefert
	\end{tabular}
	\bigskip
	\subcaption*{Analoge Pinbelegung}
	\begin{tabular}{p{0.15\textwidth} p{0.2\textwidth} p{0.6\textwidth}}
		\textbf{Analog-Pin}	& \textbf{Sensor} & \textbf{Beschreibung} \\
		A0	& Mikrofon 		& Analoge Messwerte des Mikrofons. Werden zur Fehlererkennung genutzt. \\
		A1	& Flammensensor	& Analoge Messwerte des Flammensensors. Werden zur Fehlererkennung genutzt.\\
		A2	& Lichtsensor	& Analoge Messwerte des Lichtsensors.
	\end{tabular}
\end{table}
\\
Der Lichtsensor besitzt als einziger Sensor keine direkte Anschlussmöglichkeit an einen \ac{GPIO} Pin. Somit wird der zusätzliche analoge Ausgang des Flammensensors und des Mikrofons zur Messwertüberprüfung genutzt. Der Aufbau der \ac{GPIO} Steckplatine hat einen Einfluss auf die Pinbelegung der Sensoren genommen. Wie in \fullref{fig:Kapitel2/gpio_pins_pi2.png} zusehen ist, sind die Pins 9, 14, 20 und 25 Masseanschlüsse. Die genutzten Sensoren befinden sich in unmittelbarer nähe zu diesen. Zu einem können sich Nutzer an den Positionen der Masseanschlüsse orientieren und somit ebenfalls schneller den korrekten Pin finden. Ein weiterer Vorteils ist, dass im Falle eines versehentlichen Fehlanschließens keine Gefahr für den Sensor entsteht, da beispielsweise auf den digitalen Ausgangspin keine 5V Eingangsspannung gelangen kann. Durch die feste Pinbelegung entsteht eine feste Vorgabe der Anschlussarchitektur. Die Sensoren können falsch angeschlossen werden und würden dabei ebenfalls Messdaten erzeugen, doch eine korrekte Zuweisung der Messdaten an die Sensoren wäre nicht möglich. Des Weiteren hat die feste Pinbelegung ebenso einen Einfluss auf die Implementierung der Sensoren. 
\subsection{Implementierung der Sensoren}
%TODO: Alles erklären ...
% Lichtsensor: Problematisch ist hierbei das Tageslicht, da es das gleiche Verhalten beim Sensor auslöst.
% Schocksensor:Eine Umsetzung mit diesem Modell ist nicht mögich, da eine starke Erschütterung zum detektieren benötigt.
Bevor die Sensoren implementiert werden können, muss eine Softwarearchitektur aufgebaut werden. Zuerst gibt es die Auswahl eines objektorientierten oder nicht objektorientierten Ansatzes.
%TODO: Quelle raussuchen! 
Ein Vorteil der \ac{OOP} ist die Erweiterungsfähigkeit. Eine neue Funktion kann in der Klasse niedergeschrieben werden und zur Laufzeit ausgeführt werden. Des Weiteren können mehrere Instanzen einer Klasse zur Laufzeit erzeugt werden. Somit kann eine Hauptklasse erstellt werden, die dann zur Laufzeit mehrere Objekte erzeugen kann, die jeweils eine eigene Funktionalität ausüben. Eine weitere Problemstellung in der Entwicklung der Softwarearchitektur ist die Klassenhierarchie. Statt den gewöhnlichen Ansatz einer Hauptklasse und dann jeweils einer Unterklasse mit einer Funktionalität auszubauen, wird hierbei der Ansatz einer monolithischen Architektur gewählt. Im Sensorknoten werden nur Sensoren implementiert. Damit würde es eine Überklasse geben, wovon jeder Sensor erben würde. Beim monolithischen Ansatz gibt es nur eine Klasse, die alle Methoden enthält. Erst bei der Initialisierung kann entschieden werden, welche Funktion ausgeführt werden soll. Ein Instanz einer monolithischen Klasse kann somit, falls es einen Anlass dafür gibt, unabhängig von der Initialisierung ihre Funktionsweise wechseln. Bei klassischen objektorientierten Ansatz müsse eine komplett neue Instanz erzeugt werden. Ein Nachteil der monolithischen Architektur ist die Anhäufung von Methoden in einer Klasse. Ab einem gewissen Grad wird die Klasse schwer wartbar, da zu viele Methoden kontrolliert werden müssen. Diese Größe der Klasse kann weitere Fehler, wie das nicht korrekte Bereinigen von Bugs mit sich bringen. Das größte Problem dieser Architektur ist fehlerhafte Instanziierung eines Objektes. Zur Darstellung des Problems dient folgendes Programmbeispiel:

\begin{lstlisting}[caption=Fehlerhafte Instanziierung eines Sensorobjektes,frame=single,numbers=left,language=Python]
# Initialisierung des Mikrofons
 sensor1 = Sensor(5, A0, 18)
# Korrekte Ausführung des Mikrofonsensors
<@ \textcolor{green}{\Checkmark} @> sensor1.mikrofon()
# Versuchte Ausführung der der Flammensensor Funktion mit dem Mikrofonobjekt
<@ \textcolor{red}{\XSolid} @> sensor1.flammensensor() 
\end{lstlisting}
Wie in Zeile 2 zu sehen ist, wird ein Sensorobjekt, mit der Bezeichnung "'sensor1"', mit 3 Eingabeparametern initialisiert. Diese werden im späteren Verlauf weiter erläutert. Sensor1 kann jetzt jede Methode der Sensorklasse ausführen. Dei der Initialisierung wurden die festen Angaben eines Mikrofonsensors angegeben. Damit ist die Zeile 4 die einzig korrekte Ausführung für dieses Sensorobjekt. Die Fehlerprüfung durch den Compiler wird bei dieser Architektur nicht unterstützt. Wie in Zeile 6 zu sehen ist, kann die Flammensensorfunktion aufgerufen werden. Für den Compiler ist es ein korrekter Aufruf der Flammensensormethode, jedoch würde diese lediglich fehlerhafte Messdaten zurückgeben. Die Funktionsweise der Sensorklasse wir in den folgenden Schritten erläutert.

\subsubsection*{Der Konstruktor} \label{Methode:Konstruktor}
	Wie in anderen Programmiersprachen, wird ebenfalls in Python ein Konstruktor für das Objekt benötigt. Der Konstruktor initialisiert alle notwendigen Variablen für das Objekt der Klasse. Im Falle des Sensorknotens sieht der Konstruktor wie folgt aus:
	
	\lstinputlisting[caption=Konstruktor der Sensorklasse,frame=single,numbers=left,language=Python, firstline=10, lastline=26]{Quellcode/sensor.py}

	\textsc{Eric Matthes} beschreibt in seinem Buch "Python crash course"\cite{1593276036} die Funktion \_\_init\_\_ als eine geschützte Funktionalität von Python. Der Zweck der doppelten Unterstriche seie die Abgrenzung von möglichen Namen, die ein Programmierer vergeben dürfe. Es ist üblich, dass einfache Unterstriche zum verbinden von mehreren Wörtern genutzt werden. Somit, weiß der Programmierer, dass diese besondere Funktion nicht im anders verwendet werden darf. Eine weitere Auffälligkeit ist die 'self' Variable. Nach \textsc{Eric Matthes} müsse der Parameter an erster Stelle im Konstruktor stehen. Dieser seie für den Bezug auf das Objekt relevant. Das self ist in der Funktionalität ähnlich wie das 'this' aus Java. Die weiteren Übergabeparameter haben folgende Bedeutung:
	\begin{description}
		\item[SEN\_ID] \hfill \\
			Die SEN\_ID ist die feste Nummer des Sensors. Die Nummerierung entstammt dem \fullref{Sensoren_Planung}. Hierbei Hat der Temperatursensor die Nummer 1 und der Luftfeuchtigkeitssensor die Nummer 2. Die restlichen Sensoren werden entsprechend gezählt. Die SEN\_ID wird für die Zuordnung des Messwertes zum Sensor in der Datenbank benötigt. 
		\item[Analog\_PIN] \hfill \\
			Der Analog\_PIN Übergabeparameter wird für das Ansprechen des A/D-Wanderls benötigt. Die Angaben können aus der \fullref{tab:Pinbelegung} entnommen werden.
		\item[Digital\_PIN] \hfill \\
			Der Digital\_Pin kann ebenfalls aus der \fullref{tab:Pinbelegung} entnommen werden. Die Angabe wird für Sicherheitsüberprüfungen und zum Auslesen von den digitalen Sensorwerten benutzt.
   	\end{description}
	Der Sensorname ermittelt mit Hilfe der socket Bibliothek den Namen des Betriebssystems. Damit wird der Name des Sensorknotens ermittelt. Dieser wird für die Zuweisung der Sensoren zum Sensorknoten in der Datenbank genutzt. Der eigentliche Name des jeweiligen Sensors ist für den Sensorknoten nicht von Bedeutung, den die SEN\_ID ist immer eindeutig. Der Name des Sensors wird mit Hilfe der Datenbank bestimmt.
	%TODO: Verknüpfung zur Zentraleinheit : Datenbank. Übersetzung SEN_ID zum Sensornamen
	Neben der SEN\_ID ist der Messwert in der zu übertragenden Nachricht an die Zentraleinheit enthalten. Der Messwert wird zu Beginn, als ein leerer String vorgeladen. Python setzt keine Deklaration vor der Nutzung einer Variable voraus. Die Messwertvariable wird dennoch deklariert, damit der Quellcode wartbarer wird. Die Status Variable dient als Zustandskontrolle des Sensors. Der Status des Sensors wird auf der Website wie im Kapitel BLAARRRGH %TODO: Verweis auf Website Übersicht mit dem Statusbit!
	erläutert, dargestellt. Der Zustand ändert sich explizit sobald ein Sensor detektiert wird. Die Status Variable kann folgende Zustände annehmen:
	\begin{description}
		\item[Status = 0] \hfill \\
			Bedeutet, dass der Sensor nicht angeschlossen wird. Dies ist ebenso der Defaultzustand aller Sensorobjekte.
		\item[Status = 1] \hfill \\
			Bedeutet, dass der Sensor angeschlossen ist. Dieser Zustand soll dem Benutzer signalisieren, dass der Sensor korrekt arbeitet.
		\item[Status = 2] \hfill \\
			Bedeutet, dass der Sensor defekt ist. Anders als beim Zustand 0 tritt dieser Fall erst auf, wenn ein unmöglicher Messwert gemessen wurde. Ein Beispiel hierfür ist: Falls der Temperatursensor, welcher einen Messbereich von 0 bis 50$^\circ$C hat, Messwerte unter dem Gefrierpunkt oder über 50$^\circ$C liefert.
	\end{description}
	Der Befehl in der Zeile neun dient zur Einstellung der GPIO-Pinbezeichnung. \textsc{MATT} beschreibt in sienem Blogeintrag "Simple Guide to the RPi Header and Pins"\cite{SimpleGu6:online}, dass es zwei mögliche Modi für diesen Befehl gebe. Zu einem gebe den Übergabeparameter "GPIO.BOARD" und zum anderen "GPIO.BCM". Sie würden für die verschiedenen Nummerierungsmöglichkeiten der \ac{GPIO} Schnittstelle stehen. GPIO.BOARD würde die Nummerierung der Pins nach der Position auf dem Board durchführen. Im Gegensatz dazu nutze die GPIO.BCM Nummerierung die eigentliche GPIO Pinbelegung. Diese wir in der \fullref{fig:Kapitel2/gpio_pins_pi2.png} dargestellt.\\
	Die Ausgabe von Warnungen der GPIO Bibliothek wird mit dem Befehl in der zehnten Zeile deaktiviert. Diese sind nicht notwendig, da zu einem die Sensorenknoten an keiner graphischen Ausgabe angeschlossen sind und zum anderen werden Fehler separat behandelt.\\
	Falls der Sensor einen Digitalen Anschluss hat, muss dieser initialisiert werden. Dazu dient die Kontrollstruktur von Zeile elf bis vierzehn. \textsc{Chris Hager} beschreibt in der "RPIO 0.10.0 documentation - RPIO, the Python module" den Befehl "GPIO.setup()"\space wie folgt. Der Befehl benötige als Übergabeparameter den Pin, den Modus - entweder GPIO.IN oder GPIO.OUT und die Angabe, ob der Pull-up oder Pull-down Widerstand aktiv sein solle. Im Falle der Sensoren muss das Signal als "GPIO.IN" deklariert werden. Es wird weder ein Pull-up noch ein Pull-down Widerstand angeschlossen, aus diesem Grund wird als letzter Parameter "'GPIO.PUD\_OFF"' angegeben. \\
	Die letzten zwei Befehle dienen zum Initialisieren des I$^2$C Buses. Der 'smbus.SMBus(X)' nimmt entweder den Wert 0 oder Wert 1 an. Nach einem empirischen Test hat es sich herausgestellt, dass die Raspberry Pis in der Version 2 und 3 das i2c-dev1 Interface standardmäßig nutzten. Somit muss der Befehl "smbus.SMBUS(1)" ausgeführt werden. Die Adresse des I$^2$C Ports muss ebenfalls angegeben werden. Nach dem Blogeintrag "GPIO Interface library for the Raspberry Pi"\cite{I2CPCF8592:online} von Wiring Pi seie die Adresse "0x46$_H$"\space die Standardadresse des Raspberry Pis. Damit ist der Konstruktor abgeschlossen! und es folgen die Methoden der Sensorklasse.
\subsubsection*{Aufräumfunktion}
	Diese Funktion dient zum aufräumen der \ac{GPIO} Anschlüsse. \textsc{Ben Croston} schreibt in seinem Artikel "'RPi.GPIO basics 3"' \cite{RPiGPIOb90:online}, dass die \ac{GPIO} Pins aufgeräumt werden sollten. Folgendes Problem bestehe beim Raspberry Pi. Falls in ein Port im Programm auf auf den Wert "'1"' gesetzt wurde behalte dieser den Wert ebenfalls nach dem Beenden des Programms. Würde der Nutzer versehentlich Anschluss mit einem Masseanschluss verwinden, so wäre es möglich, dass die Platte durch den Kurzschluss Schäden davon trage. Die Implementierung für die Sensorklasse sieht wie folgt aus:
	\lstinputlisting[caption=Portbereinigungsmethode mittels GPIO.cleanup,frame=single,numbers=left,language=Python, firstline=28, lastline=29]{Quellcode/sensor.py}
	Nach \textsc{Ben Croston} \cite{RPiGPIOb90:online} reinige die GPIO.cleanup Funktion nur die verwendeten Ports des jeweiligen Objektes. Somit muss diese Funktion von jeweiligen Sensorobjekten ausgeführt werden. Semantisch gesehen gehört die Funktion in die Sensorklasse, dennoch befindet sie sich eine Abstraktionsstufe über dieser. Die Pins können erst aufgeräumt werden sobald ein Sensorobjekt nicht mehr gebraucht wird. Damit kommt diese Funktion erst zur Geltung, nachdem das Hauptprogramm, wie in REFERENZHAUPTPROGRAMM zusehen,
	%TODO: REFERENZ Auf StartSensor.py hier reinhauen!
	beendet wurde.
\subsubsection*{Eventsteuerung des Flammensensors und des Mikrofons}
	Der Flammensensor unterscheidet sich in seinem Verhalten nicht vom dem Mikrofon. Da beide ein Auslösesignal zur Detektion eines Ereignisses benötigen, werden die Funktionen zusammengefasst dargestellt. Das folgende Listing stellt die Implementierungen der Eventsteuerung dar.
	\lstinputlisting[caption=Hinzufügen der Eventsteuerung für den Flammensensor und das Mikrofon,frame=single,numbers=left,language=Python, firstline=31, lastline=41]{Quellcode/sensor.py}
	Die GPIO Bibliothek bietet mit der Funktion "'add\_event\_detect"' eine Möglichkeit eigene Flankentriggerungen zu implementieren. Der Befehl benötigt die Angabe des Digitalen Pins, welche Flanken detektiert werden sollen, den darauffolgenden Methodenaufruf und zum Schluss Wiederholzeit. Der digitale Pin wird mit der Angabe "'Digital\_Pin"', wie im \fullref{Methode:Konstruktor} angegeben, festgelegt. Die GPIO Bibliothek unterstützt mit dem Parameter "'GPIO.RISING"' die steigende Flanke, mit "'GPIO.FALLING"' die fallende Flanke und "'GPIO.BOTH"' beide Flanken zu detektieren. Zur Ermittlung eines Ereignisses genügt die steigende Flanke eigentlich schon aus. Damit wäre der Ablauf des Programms gefährdet. Denn sobald ein Ereignis festgestellt wurde, wäre das Programm nicht in der Lage diesen gesetzten Zustand zu verlassen. Dafür werden beide Flanken betrachtet. Die fallende Flanke löst das zurücksetzen des Flags aus und zeigt damit dem Benutzer, dass das Problem beseitigt wurde. Ohne die fallende Flanke wäre die einzige Möglichkeit des Zurücksetzens ein Neustart des Programms. Die Angabe des "'callbacks"' legt die auszuführende Funktion bei einer Flankendetektion fest. Der letzte Parameter ist eine Analogie zum Prellverhalten von mechanischen Tastern. Damit kann eine Sperre in Millisekunden angegeben werden. Es soll eine Dopplung des Signals verhindern.
\subsection{Konfiguraton \& Testen der Sensoren}
%TODO: Unseren Code nochmal anschauen
\subsection{Priorisierung der Sensoren}
Der Hauptaspekt der Priorisierung ist die Sicherstellung, dass ein hoch priorisierter Messwert ohne Verzögerung ausgegeben wird.
%TODO: Vorgang des Messens erläutern
%TODO: Zeitkritische Abhängigkeiten erklären (messschleife beim DHT11)
%TODO: Eventgesteuerte Priorisierung
%TODO: Erweiterbarkeit
%TODO: Unsere Priorisierung erklären
%TODO: Übergang zur Übertragung!
\subsection{Übertragung der Sensordaten}
%TODO: Abstimmen mit jan - gleiche Struktur

%Jan
\section{Zentraleinheit}%Allgemein Vorinstallation!%verweis auf Planung Zentraleinheit
Damit die Zentraleinheit die Anforderungen, welche im \fullref{Planung} festgelegt wurden erfüllt, wurde folgende Software auf der Zentraleinheit vorinstalliert:
\begin{description}
	\item[MySQL] \hfill \\
	Eine MySQL Datenbankserver wurde auf der Zentraleinheit installiert, dieser dient wie im \fullref{sub:Datenbank} vorgestellt, dem Sammeln der Sensordaten. Mit den vorgestellten Programmiersprachen im \fullref{Python} und im \fullref{PHP} ist es möglich eine Verbindung zur Datenbank zu erstellen. Zusätzlich kann die Datenbank mit den zuvor erwähnten Sprachen befüllt und ausgelesen werden.
	%AUSFÜHREN MIT QUELLE WAS IST MySQL etc.
	\item[PhpMyAdmin] \hfill \\
	Zum einfacheren Erstellen und Testen, wurde eine PhpMyAdmin installiert. PhyMyAdmin ist eine grafische Oberfläche für den Webbrowser, mit der der Inhalt angezeigt und bearbeiet werden kann. Ebenso können Benutzerrechte festgelegt werden. Über die Oberfläche ist es möglich Cronjobs zu implementieren.
	%EVTL QUELLE
	\item[Apache2] \hfill \\
	Zur Darstellung, der im \fullref{sub:Webseite} geplanten Webseite, wurde ein Apache2 als Webserver installiert.
	%AUSFÜHREN MIT QUELLE WAS IST APACHE2 etc.		
\end{description}
\subsection{Empfangen der Sensordaten}
Die Scriptsprache Python muss mit folgenden Bibliotheken erweitert werden, damit eine Socketschnittstelle erstellt werden kann.
\begin{lstlisting}[caption=Einbinden der Bibliotheken für die Schnittstelle,frame=single,numbers=left,language=Python]
import socket
import json
\end{lstlisting}
Die Bibliotheken socket und json werden eingebunden. Die Bibliothek socket ist dafür zuständig, die funktionalität der Socketschnittstellt bereitzustellen. Die Bibliothek json ist in diesem Fall nur für die Codierung zuständig.\hfill
\noindent Nachfolgend sehen sie die Bereitstellung der Socketschnittstelle.
% Referenz Methode:senden
\begin{lstlisting}[caption=Bereitstellen der Socketschnittstelle,frame=single,numbers=left,language=Python]
s = socket.socket()
host = '192.168.178.1'
port = 12345
s.bind((host, port))
s.listen(5)
msg = 'Thank you for connecting'
\end{lstlisting}
Mit dem Befehl socket.socket()....

\begin{lstlisting}[caption=Speichern der Daten,frame=single,numbers=left,language=Python]
while True:
	c, addr = s.accept()
	print('Got connection from ', addr)
	data = json.loads(c.recv(4096).encode('utf-8'))
	Name = str(data["Name"])
	SEN_ID = str(data["SEN_ID"])
	Wert = str(data["Messwert"])
	adresse = str(addr[0])
\end{lstlisting}

\subsection{Befüllen der Datenbank}
Damit mit Python eine Datenbank befüllt werden kann, muss zuerst eine Bibliothek eingebunden werden.
\begin{lstlisting}[caption=Einbinden der Bibliothek für die Datenbank,frame=single,numbers=left,language=Python]
import MySQLdb as mdb
\end{lstlisting}
Die Bibliotheken MySQLdb wird einbunden und ihr Name in mdb geändert.\hfill
\noindent Danach muss der Datenbankkonnektor implementiert werden. Nachfolgenden der Quellcode für den Datenbankkonnektor.
\begin{lstlisting}[caption=Datenbankkonnekor,frame=single,numbers=left,language=Python]
try:
	con = mdb.connect('localhost', 'root', 'Piroot',
	'Sicherheitssystem')
	print("SQL-Connection successful")
except _mysql.Error, e:
	print("SQL-Connection failed. Error %d:
	%s" % (e.args[0], e.args[1]))
\end{lstlisting}
Der Datenbankkonnektor ist in zwei Blöcke unterteilt, dem try Block und dem except\_mysql.Error, e Block.

\noindent  Im try Block wird über die Funktion mdb.connect eine Verbindung hergestellt und in der Variable con gespeichert. Die in den Klammern stehenden Variablen sind v.l.n.r der Hostname, der Benutzername, das Passwort und die Datenbank die Angesprochen werden soll. Wenn die Verbindung fehlerfrei hergestellt wurde, wird über die print Funktion die Meldung "SQL-Connection successful" ausgegeben.

\noindent Im zweiten Block, dem except\_mysql.Error, e Block wird der Fehlerfall abgedeckt. Sollte die Funktion mdb.connect keine erfolgreiche Verbindung herstellen, gibt die print Funktion die Meldung "SQL-Connection failed. Error \%d:\%s" aus. An die Stelle des Platzhalters \%d wird der Fehlercode und an den Platzhalter \%s die Fehlermeldung die zurückgegeben wird geschrieben, die die Datenbank liefert.

\begin{lstlisting}[caption=Befüllen der Datenbank,frame=single,numbers=left,language=Python]
with con:
	cur = con.cursor()
	row_count = cur.execute("SELECT KN_ID FROM Sensorknoten
	WHERE Knotennamen = %s", (Name,))
	# Wenn ein Datenbankeintrag gefunden wird,
	wird die IPv4-Adresse erneuert
	if row_count == 1:
		KN_ID = cur.fetchone()
		cur.execute("""UPDATE Sensorknoten SET
		IPv4_Adresse = %s WHERE
		Knotennamen = %s""", (adresse, Name))
		cur.execute("""INSERT INTO Messwerte 
		(SEN_ID, Messwert) VALUES(%s, %s)""",
		(SEN_ID, Wert))
		# Die zuletzt erstellte ID wird übergeben
		MessID = cur.lastrowid
		cur.execute("""INSERT INTO 
		Sensorknoten_Messwerte (KN_ID, MESS_ID)
		VALUES(%s, %s)""", (KN_ID, MessID))
		# Wenn kein Datenbankeintrag gefunden wird,
		wird ein neuer Datenbankeintrag erstellt
	elif row_count == 0:
		cur.execute("""INSERT INTO Sensorknoten
		(Knotennamen, IPv4_Adresse) VALUES
		(%s, %s)""", (Name, adresse))
		# Die zuletzt erstellte ID wird übergeben
		KN_ID = cur.lastrowid
		cur.execute("""INSERT INTO Messwerte
		(SEN_ID, Messwert)VALUES(%s, %s)""",
		(SEN_ID, Wert))
		# Die zuletzt erstellte ID wird übergeben
		MessID = cur.lastrowid
		cur.execute("""INSERT INTO 
		Sensorknoten_Messwerte(KN_ID, MESS_ID)
		VALUES(%s, %s)""", (KN_ID, MessID))
con.close()
\end{lstlisting}
\subsection{Problematik Zeitsynchronisierung}
 
\section{Website}
%Harm
\subsection{Login und Logout}

Der Login, die Registrierung und der Logout ist nach der Anleitung von
wikiHow (\cite{PHP-Login}) erstellt und entsprechend angepasst worden. 
\\
Der Login besteht aus mehreren Dateien, deren Funktion in der Tabelle
(\nameref{tab:Login-Dateien}) aufgezählt ist.

\begin{table}
\caption{PHP-Login-Dateien und Funktion}
\label{tab:Login-Dateien}
\begin{tabular}{p{0.5\textwidth} p{0.45\textwidth}}
\textbf{Datei} 				& \textbf{Erklärung} \\
Login.php 						& Die Loginseite - Gleichzeitig auch die Startseite bei Aufruf der Server-IP\\
Register.php 					& Die Registrierungsseite \\
Register\_success.php & Die Seite, die nach einer erfolgreichen Registrierung angezeigt wird \\
Logout.php 						& Die Seite, die nach einem erfolgreichen Logout angezeigt wird \\
psl\_config.php 			& Festlegung von Variablen, die mehrfach verwendet werden \\
db-connect.php 				& Datenbank-Connector \\
functions.php 				& Relevante Funktionen, die benötigt werden \\
process\_login.php 		& Code der die Logindaten der Loginseite überprüft und danach auf die Übersichtsseite weiterleitet \\
register\_inc 				& Code der abläuft wenn sich ein User neu registriert \\
forms.js 							& Javascriptdatei, für das Hashen und Überprüfen der Passwörter \\
sha512.js 						& Hashfunktion nach Standard SHA-512 \\
style.css 						& CSS-Datei für zentrale Designeinstellungen \\
 \end{tabular}
\end{table}

In der Datei functions.php sind zentrale Funktionen gesammelt, die nachfolgend
beschrieben werden:

\subsubsection{sec\_session\_start}
%TODO: Session-ID und Cookie erklähren - Erledigt?
Diese Funktion vergibt eine Session-ID und legt fest, dass Cookies verwendet werden. Die Session-ID ermöglicht es Anfragen eines Clients zuordnen zu können und Antworten oder Aktualisierungen an diesen zu senden. Die Session-ID wird vom Server generiert und per Cookie an den Client übertragen. Der Client speichert das Cookie ab und sendet bei jeder Anfrage das Cookie (mit der Session-ID) an den Server. Wird keine oder eine falsche Session-ID übertragen erhält der Benutzer, die Meldung, dass er sich zuerst am System anmelden muss. Durch den Anmelde-Vorgang wird dem Client eine neue Session-ID zugewiesen.

\subsubsection{login}
Diese Funktion steuert alle notwendigen Abläufe, die den Login betreffend.\\
Aufgerufen wird die Funktion mit den Parametern Username, Passwort und der Datenbankverbindung. Die Parameter Username und Passwort werden aus POST-Werten der Loginseite übergeben während die Datenbankverbindung in der Datei db-connect.php definiert ist. Durch ein Prepared-Statement werden die benötigten Werte aus der Datenbank abgerufen. Danach wird verglichen ob der übergebene Username in der Datenbank hinterlegt ist. Existiert der Benutzer, wird zuerst durch die Funktion 'checkbrute' überprüft, ob der Benutzer momentan gesperrt ist. Ist der Benutzer nicht gesperrt, wird das Passwort überprüft und der Anwender wird auf die Seite 'Übersicht' weitergeleitet. Ist das Passwort nicht korrekt, wird der fehlgeschlagene Loginversuch in der Datenbank vermerkt und der Benutzer erhält eine Meldung, dass der Anmeldeversuch fehlgeschlagen ist. 

\subsubsection{checkbrute}

\subsubsection{login\_check}
Diese Funktion prüft ob ein Anwender eingeloggt ist und setzt den entsprechenden
Parameter, der entscheidet was der Anwender auf der Website sieht.

\subsubsection{esc\_url}

%Jan
\subsection{Übersicht}
%Alex
\subsection{Statistik}
%Alex+Jan
\subsection{Webcam}
%Harm
\subsection{Impressum}

Auf der Seite "`Impressum"' stehen die Namen der drei Autoren, der Titel des Projektes und diese Dokumentation wird zum Download angeboten. Ansonsten ist keine weitere Funktionalität implementiert.
%Alle
\section{Refactoring}
%Alle
\section{Systemtest}
